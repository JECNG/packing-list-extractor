<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì‚¬ì´ì¦ˆ ê·¸ë¦¬ë“œ íŒŒì‹± í…ŒìŠ¤íŠ¸</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
        }
        
        h1 {
            margin-bottom: 20px;
            color: #333;
        }
        
        .controls {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .controls input, .controls button {
            margin-right: 10px;
            margin-bottom: 10px;
            padding: 8px 16px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        
        .controls button {
            background: #667eea;
            color: white;
            border: none;
            cursor: pointer;
        }
        
        .controls button:hover {
            background: #5568d3;
        }
        
        .viewer-container {
            display: flex;
            gap: 20px;
        }
        
        .pdf-viewer {
            flex: 1;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative;
            overflow: auto;
            max-height: 800px;
        }
        
        .debug-panel {
            flex: 1;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-height: 800px;
            overflow-y: auto;
        }
        
        #pdf-canvas {
            border: 1px solid #ddd;
            max-width: 100%;
        }
        
        .highlight-rect {
            position: absolute;
            border: 2px solid #ff6b6b;
            background: rgba(255, 107, 107, 0.2);
            pointer-events: none;
        }
        
        .size-cell {
            border: 2px solid #4facfe;
            background: rgba(79, 172, 254, 0.2);
        }
        
        .qty-cell {
            border: 2px solid #43e97b;
            background: rgba(67, 233, 123, 0.2);
        }
        
        .field-extracted-text {
            position: absolute;
            background: rgba(255, 215, 0, 0.8);
            border: 2px solid #ff9800;
            padding: 3px 6px;
            font-size: 11px;
            font-weight: bold;
            color: #000;
            pointer-events: none;
            z-index: 10;
            border-radius: 3px;
            word-break: break-all;
            max-width: 200px;
        }
        
        .field-colors {
            code: #667eea;
            brand: #f093fb;
            color: #fa709a;
            size_grid: #ff6b6b;
        }
        
        .debug-section {
            margin-bottom: 20px;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 5px;
        }
        
        .debug-section h3 {
            margin-bottom: 10px;
            color: #333;
        }
        
        .debug-section pre {
            background: #fff;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 12px;
        }
        
        .cell-info {
            display: inline-block;
            padding: 5px 10px;
            margin: 5px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ” ëª¨ë“  í•„ë“œ ì¶”ì¶œ ì‹œê°í™” í…ŒìŠ¤íŠ¸</h1>
        
        <div class="controls">
            <input type="file" id="pdf-file" accept=".pdf">
            <input type="file" id="template-file" accept=".json">
            <button onclick="loadFiles()">íŒŒì¼ ë¡œë“œ</button>
            <button onclick="startTest()">í…ŒìŠ¤íŠ¸ ì‹œì‘</button>
        </div>
        
        <div class="viewer-container">
            <div class="pdf-viewer" id="pdf-viewer">
                <canvas id="pdf-canvas"></canvas>
            </div>
            
            <div class="debug-panel" id="debug-panel">
                <div class="debug-section">
                    <h3>ë¡œë“œ ìƒíƒœ</h3>
                    <div id="status">íŒŒì¼ì„ ì„ íƒí•˜ê³  ë¡œë“œí•˜ì„¸ìš”</div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        
        let pdfDoc = null;
        let currentPage = null;
        let template = null;
        let pageScale = 1.5;
        let pageViewport = null;
        let canvasContext = null;
        
        async function loadFiles() {
            const pdfFile = document.getElementById('pdf-file').files[0];
            const templateFile = document.getElementById('template-file').files[0];
            
            if (!pdfFile) {
                alert('PDF íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”');
                return;
            }
            
            if (!templateFile) {
                alert('í…œí”Œë¦¿ íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”');
                return;
            }
            
            // PDF ë¡œë“œ
            const pdfArrayBuffer = await pdfFile.arrayBuffer();
            pdfDoc = await pdfjsLib.getDocument({ data: pdfArrayBuffer }).promise;
            currentPage = await pdfDoc.getPage(1);
            pageViewport = currentPage.getViewport({ scale: pageScale });
            
            // Canvas ì„¤ì •
            const canvas = document.getElementById('pdf-canvas');
            canvas.width = pageViewport.width;
            canvas.height = pageViewport.height;
            canvasContext = canvas.getContext('2d');
            
            await currentPage.render({
                canvasContext: canvasContext,
                viewport: pageViewport
            }).promise;
            
            // í…œí”Œë¦¿ ë¡œë“œ
            const templateText = await templateFile.text();
            template = JSON.parse(templateText);
            
            updateStatus('íŒŒì¼ ë¡œë“œ ì™„ë£Œ');
            renderTemplateHighlights();
        }
        
        const fieldColors = {
            code: '#667eea',
            brand: '#f093fb',
            color: '#fa709a',
            size_grid: '#ff6b6b'
        };
        
        function renderTemplateHighlights() {
            if (!template || !currentPage) return;
            
            const viewer = document.getElementById('pdf-viewer');
            viewer.querySelectorAll('.highlight-rect').forEach(el => el.remove());
            
            const fields = template.test?.fields || template.fields || [];
            
            fields.forEach(field => {
                const bbox = field.bbox;
                const color = fieldColors[field.field] || '#ff6b6b';
                const rect = createHighlightRect(bbox, color, field.field);
                viewer.appendChild(rect);
            });
        }
        
        function createHighlightRect(bbox, color, label) {
            const rect = document.createElement('div');
            rect.className = 'highlight-rect';
            
            // PDF ì¢Œí‘œë¥¼ ìº”ë²„ìŠ¤ ì¢Œí‘œë¡œ ë³€í™˜
            const canvasX0 = (bbox.x0 / pageViewport.width) * pageViewport.width;
            const canvasY0 = pageViewport.height - ((bbox.y0 / pageViewport.height) * pageViewport.height);
            const canvasX1 = (bbox.x1 / pageViewport.width) * pageViewport.width;
            const canvasY1 = pageViewport.height - ((bbox.y1 / pageViewport.height) * pageViewport.height);
            
            rect.style.left = Math.min(canvasX0, canvasX1) + 'px';
            rect.style.top = Math.min(canvasY0, canvasY1) + 'px';
            rect.style.width = Math.abs(canvasX1 - canvasX0) + 'px';
            rect.style.height = Math.abs(canvasY1 - canvasY0) + 'px';
            rect.style.borderColor = color;
            rect.style.backgroundColor = color.replace(')', ', 0.2)').replace('rgb', 'rgba');
            rect.title = label;
            
            return rect;
        }
        
        async function startTest() {
            if (!pdfDoc || !template) {
                alert('ë¨¼ì € íŒŒì¼ì„ ë¡œë“œí•˜ì„¸ìš”');
                return;
            }
            
            updateStatus('ì¶”ì¶œ ì‹œì‘...');
            
            const page = await pdfDoc.getPage(1);
            const textContent = await page.getTextContent();
            
            const fields = template.test?.fields || template.fields || [];
            const extractedData = {};
            
            // ëª¨ë“  í•„ë“œ ì²˜ë¦¬
            for (const field of fields) {
                const fieldName = field.field;
                const bbox = field.bbox;
                const fieldType = field.type || 'text';
                
                // í•„ë“œ ì˜ì—­ ë‚´ì˜ ë¬¸ì ì¶”ì¶œ
                const chars_in_field = [];
                
                textContent.items.forEach(item => {
                    const transform = item.transform;
                    const x = transform[4];
                    const y = transform[5]; // PDF ì¢Œí‘œê³„ (ìœ„ê°€ í° ê°’)
                    
                    // í•„ë“œ ì˜ì—­ ë‚´ì¸ì§€ í™•ì¸
                    if (x >= bbox.x0 && x <= bbox.x1 && y >= bbox.y1 && y <= bbox.y0) {
                        chars_in_field.push({
                            text: item.str,
                            x: x,
                            y: y
                        });
                    }
                });
                
                // í•„ë“œë³„ë¡œ ì¶”ì¶œ
                if (fieldName === 'size_grid' && fieldType === 'table') {
                    extractedData[fieldName] = parseSizeGrid(chars_in_field, bbox);
                } else {
                    extractedData[fieldName] = extractTextField(chars_in_field, bbox);
                }
                
                // ì¶”ì¶œëœ í…ìŠ¤íŠ¸ ì‹œê°í™”
                visualizeExtractedText(fieldName, bbox, extractedData[fieldName], fieldType);
            }
            
            // ë””ë²„ê·¸ ì •ë³´ í‘œì‹œ
            showDebugInfo(extractedData, fields, textContent);
        }
        
        function extractTextField(chars, bbox) {
            if (!chars || chars.length === 0) return null;
            
            // Y ìœ„ì¹˜ë³„ë¡œ ê·¸ë£¹í™”
            const yGroups = {};
            chars.forEach(char => {
                const yRounded = Math.round(char.y);
                if (!yGroups[yRounded]) {
                    yGroups[yRounded] = [];
                }
                yGroups[yRounded].push(char);
            });
            
            // ê° Y ê·¸ë£¹ì—ì„œ í…ìŠ¤íŠ¸ ì¶”ì¶œ
            const textLines = [];
            const sortedY = Object.keys(yGroups).map(k => parseInt(k)).sort((a, b) => b - a);
            
            sortedY.forEach(y => {
                const rowChars = yGroups[y].sort((a, b) => a.x - b.x);
                const lineText = rowChars.map(c => c.text).join('').trim();
                if (lineText) {
                    textLines.push(lineText);
                }
            });
            
            return textLines.length > 0 ? textLines.join(' ') : null;
        }
        
        function visualizeExtractedText(fieldName, bbox, extractedValue, fieldType) {
            const viewer = document.getElementById('pdf-viewer');
            
            // ê¸°ì¡´ ì¶”ì¶œ í…ìŠ¤íŠ¸ ì œê±°
            viewer.querySelectorAll(`.field-extracted-text[data-field="${fieldName}"]`).forEach(el => el.remove());
            
            if (!extractedValue) return;
            
            const color = fieldColors[fieldName] || '#ff6b6b';
            const textDiv = document.createElement('div');
            textDiv.className = 'field-extracted-text';
            textDiv.setAttribute('data-field', fieldName);
            
            let displayText = '';
            if (fieldType === 'table' && typeof extractedValue === 'object') {
                displayText = JSON.stringify(extractedValue).substring(0, 100) + '...';
            } else {
                displayText = String(extractedValue).substring(0, 50);
                if (String(extractedValue).length > 50) displayText += '...';
            }
            
            textDiv.textContent = `${fieldName}: ${displayText}`;
            textDiv.style.borderColor = color;
            textDiv.style.backgroundColor = color + 'CC';
            
            // í•„ë“œ ì˜ì—­ ìœ„ì— í‘œì‹œ
            const canvasX0 = (bbox.x0 / pageViewport.width) * pageViewport.width;
            const canvasY0 = pageViewport.height - ((bbox.y0 / pageViewport.height) * pageViewport.height);
            
            textDiv.style.left = canvasX0 + 'px';
            textDiv.style.top = (canvasY0 - 25) + 'px';
            
            viewer.appendChild(textDiv);
        }
        
        function showDebugInfo(extractedData, fields, textContent) {
            const panel = document.getElementById('debug-panel');
            panel.innerHTML = '';
            
            // ì „ì²´ ì¶”ì¶œ ê²°ê³¼
            const summarySection = document.createElement('div');
            summarySection.className = 'debug-section';
            summarySection.innerHTML = `
                <h3>ğŸ“Š ì „ì²´ ì¶”ì¶œ ê²°ê³¼</h3>
                <pre>${JSON.stringify(extractedData, null, 2)}</pre>
            `;
            panel.appendChild(summarySection);
            
            // ê° í•„ë“œë³„ ìƒì„¸ ì •ë³´
            fields.forEach(field => {
                const fieldName = field.field;
                const bbox = field.bbox;
                const fieldType = field.type || 'text';
                
                // í•„ë“œ ì˜ì—­ ë‚´ì˜ ë¬¸ì ì¶”ì¶œ
                const chars_in_field = [];
                textContent.items.forEach(item => {
                    const transform = item.transform;
                    const x = transform[4];
                    const y = transform[5];
                    if (x >= bbox.x0 && x <= bbox.x1 && y >= bbox.y1 && y <= bbox.y0) {
                        chars_in_field.push({
                            text: item.str,
                            x: x,
                            y: y
                        });
                    }
                });
                
                const fieldSection = document.createElement('div');
                fieldSection.className = 'debug-section';
                fieldSection.style.borderLeft = `4px solid ${fieldColors[fieldName] || '#ff6b6b'}`;
                
                let fieldDetail = `
                    <h3 style="color: ${fieldColors[fieldName] || '#ff6b6b'}">í•„ë“œ: ${fieldName} (${fieldType})</h3>
                    <div><strong>ì˜ì—­:</strong> X: ${bbox.x0.toFixed(2)} ~ ${bbox.x1.toFixed(2)}, Y: ${bbox.y0.toFixed(2)} ~ ${bbox.y1.toFixed(2)}</div>
                    <div><strong>ì¶”ì¶œëœ ë¬¸ì ìˆ˜:</strong> ${chars_in_field.length}</div>
                    <div><strong>ì¶”ì¶œ ê²°ê³¼:</strong></div>
                    <pre>${JSON.stringify(extractedData[fieldName], null, 2)}</pre>
                `;
                
                // Y ìœ„ì¹˜ë³„ ê·¸ë£¹í™” ì •ë³´
                if (chars_in_field.length > 0) {
                    const yGroups = {};
                    chars_in_field.forEach(char => {
                        const yRounded = Math.round(char.y);
                        if (!yGroups[yRounded]) {
                            yGroups[yRounded] = [];
                        }
                        yGroups[yRounded].push(char);
                    });
                    
                    const yPositions = Object.keys(yGroups).map(k => parseInt(k)).sort((a, b) => b - a);
                    
                    fieldDetail += `
                        <div style="margin-top: 10px;"><strong>Y ìœ„ì¹˜ë³„ ê·¸ë£¹ (${yPositions.length}ê°œ í–‰):</strong></div>
                        <div style="font-size: 11px; margin-top: 5px;">
                            ${yPositions.slice(0, 5).map(y => {
                                const rowChars = yGroups[y].sort((a, b) => a.x - b.x);
                                const rowText = rowChars.map(c => c.text).join('');
                                return `Y=${y}: "${rowText.substring(0, 50)}${rowText.length > 50 ? '...' : ''}"`;
                            }).join('<br>')}
                            ${yPositions.length > 5 ? `<br>... (ì´ ${yPositions.length}ê°œ í–‰)` : ''}
                        </div>
                    `;
                }
                
                fieldSection.innerHTML = fieldDetail;
                panel.appendChild(fieldSection);
            });
        }
        
        function parseSizeGrid(chars, bbox) {
            // Y ìœ„ì¹˜ë³„ë¡œ ê·¸ë£¹í™”
            const yGroups = {};
            chars.forEach(char => {
                const yRounded = Math.round(char.y);
                if (!yGroups[yRounded]) {
                    yGroups[yRounded] = [];
                }
                yGroups[yRounded].push(char);
            });
            
            const sortedY = Object.keys(yGroups).map(k => parseInt(k)).sort((a, b) => b - a);
            
            if (sortedY.length < 2) {
                updateStatus('í–‰ì´ 2ê°œ ë¯¸ë§Œì…ë‹ˆë‹¤');
                return;
            }
            
            // ì…€ ì¶”ì¶œ í•¨ìˆ˜
            function extractCells(rowChars) {
                const sorted = rowChars.sort((a, b) => a.x - b.x);
                const cells = [];
                let currentCell = [];
                let prevX = null;
                const threshold = 15;
                
                sorted.forEach(char => {
                    if (prevX !== null && Math.abs(char.x - prevX) > threshold) {
                        if (currentCell.length > 0) {
                            const text = currentCell.map(c => c.text).join('').trim();
                            if (text) {
                                const xStart = Math.min(...currentCell.map(c => c.x));
                                const xEnd = Math.max(...currentCell.map(c => c.x));
                                const xCenter = (xStart + xEnd) / 2;
                                cells.push({ text, xCenter, xStart, xEnd });
                            }
                            currentCell = [];
                        }
                    }
                    currentCell.push(char);
                    prevX = char.x;
                });
                
                if (currentCell.length > 0) {
                    const text = currentCell.map(c => c.text).join('').trim();
                    if (text) {
                        const xStart = Math.min(...currentCell.map(c => c.x));
                        const xEnd = Math.max(...currentCell.map(c => c.x));
                        const xCenter = (xStart + xEnd) / 2;
                        cells.push({ text, xCenter, xStart, xEnd });
                    }
                }
                
                return cells;
            }
            
            // ê° í–‰ì—ì„œ ì…€ ì¶”ì¶œ
            const rowCells = {};
            sortedY.forEach(y => {
                const cells = extractCells(yGroups[y]);
                if (cells.length > 0) {
                    rowCells[y] = cells;
                }
            });
            
            // size í–‰ê³¼ qty í–‰ ì°¾ê¸°
            let sizeRow = null;
            let qtyRow = null;
            
            for (const y of sortedY) {
                const cells = rowCells[y];
                if (!cells) continue;
                
                const allNumeric = cells.every(cell => {
                    const cleaned = cell.text.replace('Â½', '').replace('.', '').replace(',', '').replace('-', '').replace(' ', '');
                    return cleaned && /^\d+$/.test(cleaned);
                });
                
                if (allNumeric && !qtyRow) {
                    qtyRow = { y, cells };
                } else if (!sizeRow && cells.some(c => c.text.match(/\d+/))) {
                    sizeRow = { y, cells };
                }
            }
            
            // ì‹œê°í™”
            visualizeCells(sizeRow, qtyRow);
            
            // ê²°ê³¼ í‘œì‹œ
            showParsingResult(sizeRow, qtyRow);
        }
        
        function visualizeCells(sizeRow, qtyRow) {
            const viewer = document.getElementById('pdf-viewer');
            viewer.querySelectorAll('.size-cell, .qty-cell').forEach(el => el.remove());
            
            function drawCells(row, className, label) {
                if (!row) return;
                
                row.cells.forEach(cell => {
                    const rect = document.createElement('div');
                    rect.className = `highlight-rect ${className}`;
                    
                    const canvasX0 = (cell.xStart / pageViewport.width) * pageViewport.width;
                    const canvasY0 = pageViewport.height - ((row.y / pageViewport.height) * pageViewport.height) - 20;
                    const canvasX1 = (cell.xEnd / pageViewport.width) * pageViewport.width;
                    const canvasY1 = canvasY0 - 20;
                    
                    rect.style.left = Math.min(canvasX0, canvasX1) + 'px';
                    rect.style.top = Math.min(canvasY0, canvasY1) + 'px';
                    rect.style.width = Math.abs(canvasX1 - canvasX0) + 'px';
                    rect.style.height = 20 + 'px';
                    rect.title = `${label}: ${cell.text}`;
                    rect.textContent = cell.text;
                    rect.style.fontSize = '10px';
                    rect.style.padding = '2px';
                    rect.style.display = 'flex';
                    rect.style.alignItems = 'center';
                    rect.style.justifyContent = 'center';
                    
                    viewer.appendChild(rect);
                });
            }
            
            drawCells(sizeRow, 'size-cell', 'Size');
            drawCells(qtyRow, 'qty-cell', 'Qty');
        }
        
        function showParsingResult(sizeRow, qtyRow) {
            const panel = document.getElementById('debug-panel');
            
            const resultSection = document.createElement('div');
            resultSection.className = 'debug-section';
            
            if (!sizeRow || !qtyRow) {
                resultSection.innerHTML = `
                    <h3>íŒŒì‹± ê²°ê³¼</h3>
                    <div style="color: red;">Size í–‰ ë˜ëŠ” Qty í–‰ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤</div>
                    <div>Size í–‰: ${sizeRow ? 'ë°œê²¬' : 'ì—†ìŒ'}</div>
                    <div>Qty í–‰: ${qtyRow ? 'ë°œê²¬' : 'ì—†ìŒ'}</div>
                `;
                panel.appendChild(resultSection);
                return;
            }
            
            // ë§¤í•‘ ê²°ê³¼
            const mapping = {};
            sizeRow.cells.forEach(sizeCell => {
                let matchedQty = null;
                let minDist = Infinity;
                
                qtyRow.cells.forEach(qtyCell => {
                    if ((sizeCell.xStart <= qtyCell.xCenter && qtyCell.xCenter <= sizeCell.xEnd) ||
                        (qtyCell.xStart <= sizeCell.xCenter && sizeCell.xCenter <= qtyCell.xEnd)) {
                        matchedQty = qtyCell.text;
                    } else {
                        const dist = Math.abs(qtyCell.xCenter - sizeCell.xCenter);
                        if (dist < minDist) {
                            minDist = dist;
                            matchedQty = qtyCell.text;
                        }
                    }
                });
                
                const numbers = matchedQty ? matchedQty.match(/\d+/) : null;
                mapping[sizeCell.text] = numbers ? parseInt(numbers[0]) : 0;
            });
            
            resultSection.innerHTML = `
                <h3>íŒŒì‹± ê²°ê³¼</h3>
                <div><strong>Size í–‰ (Y=${sizeRow.y}):</strong></div>
                <div>${sizeRow.cells.map(c => `<span class="cell-info">${c.text}</span>`).join('')}</div>
                <div style="margin-top: 10px;"><strong>Qty í–‰ (Y=${qtyRow.y}):</strong></div>
                <div>${qtyRow.cells.map(c => `<span class="cell-info">${c.text}</span>`).join('')}</div>
                <div style="margin-top: 10px;"><strong>ë§¤í•‘ ê²°ê³¼:</strong></div>
                <pre>${JSON.stringify(mapping, null, 2)}</pre>
            `;
            panel.appendChild(resultSection);
        }
        
        function updateStatus(msg) {
            const status = document.getElementById('status');
            status.textContent = msg;
        }
    </script>
</body>
</html>

